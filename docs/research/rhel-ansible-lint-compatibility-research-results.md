Strategic Analysis and Recommendation for RHEL 9 and RHEL 10 Container Image Support for Ansible AutomationExecutive Summary and Strategic RecommendationsThis report presents a comprehensive analysis to guide the strategic decision regarding container image support for ansible-lint across Red Hat Enterprise Linux (RHEL) 9 and the newly released RHEL 10. The central challenge stems from a fundamental and deliberate divergence in the version of ansible-core supplied within the respective operating systems. RHEL 9 has stabilized on ansible-core 2.14 for its entire lifecycle, while RHEL 10 ships with the more modern ansible-core 2.16. This incompatibility is not a transient issue but a strategic choice by Red Hat to ensure long-term stability, creating two distinct automation ecosystems that cannot be effectively served by a single, unified container image.A thorough evaluation of the underlying Universal Base Images (UBI) reveals that RHEL 10 offers significant, generational advancements over RHEL 9. The UBI 10 minimal image is approximately 16% smaller, leading to faster deployments and lower storage costs. Furthermore, RHEL 10 delivers superior performance due to its modern kernel and toolchain and introduces a new paradigm of security with features like Post-Quantum Cryptography (PQC), enhanced SELinux, and integrated compliance roles. Attempting to unify support in a single image would neutralize these advantages and introduce unacceptable levels of complexity and risk.Strategic Recommendation:Based on the extensive technical analysis of compatibility, performance, security, and long-term maintainability, this report unequivocally recommends the adoption of a separate, version-specific container image strategy. This involves creating and maintaining two distinct images: one built on UBI 9 for the RHEL 9 ecosystem and another built on UBI 10 for the RHEL 10 ecosystem.Key Justifications for this Recommendation:Mitigates Critical Compatibility Risks: Acknowledges and aligns with the intentional ansible-core version divergence between RHEL 9 and RHEL 10, eliminating the risk of runtime failures and dependency conflicts inherent in a unified approach.Maximizes Performance and Security: Allows the RHEL 10-based image to fully leverage the native performance and security enhancements of the new platform, including a smaller footprint, faster execution, and future-proof cryptography.Ensures a Stable and Predictable User Experience: Provides enterprise customers with clear, reliable, and optimized tools for their specific environments, reducing confusion and minimizing support incidents.Reduces Total Cost of Ownership (TCO): Avoids the immense complexity, high development cost, and significant support burden associated with a fragile, unified image in favor of two simple, automatable, and robust build pipelines.This dual-image strategy is the most prudent, stable, and forward-looking path. It provides a superior product to customers, aligns with Red Hat's platform strategy, and establishes a scalable model for supporting future RHEL releases.The Ansible Core Divergence: A Foundational Compatibility ChallengeThe primary technical driver necessitating this strategic analysis is a deliberate and permanent divergence in the Ansible Core versions supplied by Red Hat within the RHEL 9 and RHEL 10 AppStream repositories. This is not a simple version bump but a foundational split that has profound implications for any tooling, such as ansible-lint, that depends on the Ansible engine. Understanding this divergence is critical to formulating a viable container strategy.Analysis of Ansible Core Versions in RHEL AppStreamsRed Hat's strategy for including Ansible Core in RHEL is to enable its own supported automation content, such as RHEL system roles and Insights remediation playbooks.1 The versioning of this component is therefore tightly coupled to the support lifecycle of the host operating system itself.RHEL 9's Ansible Core StabilizationFor Red Hat Enterprise Linux 9, a strategic decision was made to stabilize the version of ansible-core to ensure predictable support throughout the operating system's long lifecycle.Early minor releases of RHEL 9 followed a pattern of updating ansible-core: RHEL 9.0 shipped with version 2.12, and RHEL 9.1 included version 2.13.1Beginning with RHEL 9.2, the provided version was updated to ansible-core 2.14. Subsequently, Red Hat announced that this version, 2.14, would be supported for the remainder of the entire RHEL 9 lifecycle.1 This commitment extends to May 2032, making ansible-core 2.14 a long-term support anchor for the RHEL 9 platform.2 The RHEL 9.6 AppStream, for instance, provides ansible-core-2.14.18-1.el9.3This decision was explicitly made to resolve "challenges aligning support lifecycles between RHEL, Ansible Core and Python".1 Underscoring this tight integration, RHEL 9.2 initially shipped ansible-core 2.14 with a dependency on Python 3.11. However, in RHEL 9.3, this was reverted to a dependency on Python 3.9, the official system Python version supported for the full RHEL 9 lifecycle.1 This move highlights the non-negotiable link between the OS, its core components, and the automation engine it supports. Any attempt to deviate from this established baseline within a RHEL 9 environment creates an unsupported and high-risk configuration.RHEL 10's Modernized Ansible CoreIn contrast to RHEL 9's focus on long-term stability, RHEL 10 adopts a more current version of the automation engine, reflecting the platform's overall modernization.The RHEL 10.0 AppStream repository ships with ansible-core 2.16.14-1.el10.3 This represents a significant two-major-version jump from the stabilized version in RHEL 9.This newer version of Ansible Core is paired with RHEL 10's updated system components, including the default system Python 3.12.5This split means that for the foreseeable future, any environment containing both RHEL 9 and RHEL 10 systems will be operating with two fundamentally different, officially supported versions of Ansible Core.Implications for ansible-lint Compatibility and FeaturesThe ansible-lint tool, while distributed separately, is not a standalone binary. It is deeply integrated with and dependent upon the underlying ansible-core libraries to function correctly. It uses these libraries to parse playbooks, understand module specifications, and validate syntax against the rules of a specific Ansible version.6 This direct dependency makes it impossible to treat the linter as a version-agnostic tool.The Linter's Versioning Philosophy: The ansible-lint project's official stance is to support only the last two major versions of Ansible. Furthermore, it explicitly recommends using the newest version of ansible-lint possible, as one of its primary goals is to help users upgrade their code to be compatible with newer Ansible releases.7 This forward-looking philosophy is fundamentally at odds with the long-term, static nature of ansible-core in RHEL 9.Divergent Rule Sets and Features: An ansible-lint version designed for ansible-core 2.16 will include rules that validate new syntax, check for new module arguments, and flag features that were deprecated or removed after version 2.14. Running such a linter against Ansible content intended for a pure RHEL 9 environment (using ansible-core 2.14) would generate a high volume of false positives, incorrectly flagging valid syntax as erroneous. Conversely, an older linter compatible with ansible-core 2.14 would be completely unaware of the new features, best practices, and deprecations introduced in versions 2.15 and 2.16, rendering it ineffective and potentially dangerous for linting content intended for a RHEL 10 environment.10The technical reality is that the ansible-core versions in RHEL 9 and RHEL 10 constitute two distinct ecosystems. A single linter configuration cannot effectively or safely serve both. This reality is summarized in the compatibility matrix below.AttributeRHEL 9 (UBI 9)RHEL 10 (UBI 10)RHEL Lifecycle EndMay 2032 2May 2035 2System PythonPython 3.9 1Python 3.12 5AppStream ansible-core2.14.x (Frozen for lifecycle) 12.16.x (Current GA version) 3Supported ansible-lintVersions compatible with ansible-core 2.14Versions compatible with ansible-core 2.16+Key ConsiderationMust not introduce features or rules incompatible with the 2.14 runtime.Can leverage the latest ansible-lint rules and features for modern Ansible.Base Image Analysis: Performance, Security, and ComplianceBeyond the critical Ansible compatibility issue, the choice of container base image is also influenced by the inherent capabilities of the underlying operating system. An analysis of Red Hat Universal Base Image (UBI) 9 versus UBI 10 reveals that RHEL 10 is not merely an incremental update but a significant generational leap in performance, security, and efficiency. These platform-level differences provide compelling reasons to treat the two as distinct offerings.Performance and Resource Implications (UBI 9 vs. UBI 10)The base image forms the foundation of the container, and its characteristics directly impact storage costs, deployment speed, and runtime performance. In these areas, UBI 10 demonstrates clear advantages.Container Image Size: A direct comparison of the minimal base images shows a significant size reduction in the newer version. The redhat/ubi9-minimal:9.6 image has a compressed size of 37.8 MB.12 In contrast, the redhat/ubi10-beta/ubi-minimal:10.0-beta image is substantially smaller at 31.7 MB compressed.13 This represents a ~16% reduction in size. In enterprise environments with large-scale container deployments, this reduction translates directly into lower container registry storage costs, reduced network bandwidth consumption, and faster image pull times, accelerating CI/CD pipelines and application scaling.Runtime Performance: While container-specific benchmarks are not available, host-level performance comparisons provide strong indicators of the expected runtime behavior. Independent benchmarks of the RHEL 10 beta against RHEL 9.5 stable on modern AMD EPYC server hardware showed that RHEL 10 "looks great" and can deliver faster results.14 This performance uplift is attributed to major upgrades in foundational components that directly benefit containerized workloads:Kernel: RHEL 10 uses the modern Linux Kernel 6.12, a substantial advance over the 5.14 kernel in RHEL 9.5 This brings improvements in the process scheduler, memory management, I/O handling, and networking stack, all of which contribute to more efficient container execution.Compiler and Toolchain: RHEL 10 defaults to GCC 14.2, compared to GCC 11.5 in RHEL 9.5.15 A modern compiler can produce more highly optimized binaries, leading to faster application performance.Hardware Optimization: RHEL 10 mandates the x86-64-v3 microarchitecture as a minimum requirement. This allows all binaries in the distribution, and by extension within the UBI 10 image, to be compiled with support for advanced instruction sets like AVX and AVX2, providing a significant performance boost for computationally intensive tasks.14Security and Compliance Posture DivergenceSecurity is a paramount concern for enterprise deployments, and RHEL 10 introduces a new security paradigm that moves beyond the robust foundation of RHEL 9 to address emerging and future threats.A Generational Leap in Security: RHEL 10 is not just an update; it represents a strategic shift in the platform's security value proposition.Post-Quantum Cryptography (PQC): RHEL 10 is the first major enterprise Linux distribution to integrate FIPS-compliant post-quantum cryptography algorithms.16 This is a forward-looking feature designed to protect sensitive data against "harvest now, decrypt later" attacks, where encrypted data is collected today with the intent of being decrypted by future quantum computers. For organizations in regulated industries or those with long-term data retention requirements, this is a critical differentiator.Improved and More Usable SELinux: While SELinux has long been a cornerstone of RHEL security, the implementation in RHEL 10 has been enhanced for greater flexibility and usability. It features more intuitive configuration, improved auditing, and streamlined troubleshooting tools, lowering the barrier for administrators to implement and maintain strong mandatory access controls within containerized environments.16Encrypted DNS: RHEL 10 provides native integration for both DNS over HTTPS (DoH) and DNS over TLS (DoT).16 This protects DNS queries from interception and manipulation, a crucial capability for implementing modern zero-trust security architectures.Integrated Compliance Roles: A significant operational improvement in RHEL 10 is the introduction of ready-to-use system roles for automating security compliance. These roles allow administrators to enforce standards such as CIS benchmarks or STIG profiles with pre-defined, tested Ansible playbooks, drastically simplifying the process of hardening systems and containers compared to the manual or custom scripting required in RHEL 9.19UBI Licensing and Redistribution: A key enabler for any container strategy is the licensing of the base image. Both UBI 9 and UBI 10 are governed by the Red Hat UBI End-User License Agreement (EULA), which makes their components freely redistributable.23 This allows for the building and sharing of container images with customers and the wider community, regardless of their Red Hat subscription status. This is a critical feature that underpins the viability of distributing our ansible-lint tool. It is important to note, however, that adding packages from standard (non-UBI) RHEL repositories into a UBI-based image can reintroduce licensing restrictions that limit redistribution.24The differences between the two platforms are substantial enough that treating them as interchangeable would be a strategic error. A UBI 10-based container is not just an update; it is a superior product offering tangible benefits in performance and security.FeatureRHEL 9 UBIRHEL 10 UBIImpact on Containerized ansible-lintKernel Version5.14 26.12 5Improved performance, efficiency, and security syscalls in RHEL 10.Minimal Image Size~37.8 MB 12~31.7 MB 13Faster pull times, lower storage costs, and reduced attack surface for RHEL 10.CryptographyOpenSSL 3.0, FIPS 140-2 16Post-Quantum Cryptography (PQC), TLS 1.3 default 16RHEL 10 offers future-proofed data protection for sensitive automation tasks.Access ControlSELinux 16Enhanced, more usable SELinux 16Easier to run ansible-lint in a securely confined container on RHEL 10.ComplianceManual/custom playbooks 20Integrated System Roles for CIS/STIG 19Simplifies building and deploying hardened, compliant ansible-lint containers.The Core Decision: Unified vs. Separate Container Image StrategySynthesizing the foundational ansible-core incompatibility and the significant platform differences between RHEL 9 and RHEL 10, the central strategic question can now be addressed: should a unified container image be pursued, or should separate, version-specific images be maintained? The analysis concludes that the risks and compromises of a unified approach far outweigh its perceived benefits, making a separate image strategy the only viable path forward.Option A: The Unified Image Approach (Not Recommended)The concept of a unified image involves building a single Docker image, likely with a :latest tag, that contains logic to detect its runtime environment and install the appropriate versions of ansible-lint and its dependencies. This approach, while superficially appealing for its promise of a single artifact, is fraught with technical complexity and operational risk.Implementation Complexity and Brittleness: A unified Dockerfile would require complex multi-stage builds or a sophisticated entrypoint script. This script would need to reliably detect the host environment (e.g., RHEL 9 vs. RHEL 10) and then conditionally install either ansible-core 2.14 or 2.16, along with their respective dependencies. This creates a fragile artifact where a failure in the detection logic could lead to a completely non-functional container. This approach is difficult to develop, test, and maintain over time.Insurmountable Dependency Conflicts: The core challenge lies in managing the conflicting dependency trees of ansible-core 2.14 and 2.16 within a single image filesystem. These versions rely on different versions of Python and other system libraries. Attempting to install both side-by-side would lead to a classic "dependency hell" scenario, likely requiring complex workarounds that would bloat the image and increase its instability.Compromised Performance and Security: To function, a unified image would likely need to be based on the lowest common denominator, UBI 9, thereby forfeiting the 16% size reduction, superior runtime performance, and advanced security features of UBI 10. Alternatively, it would have to carry the dependency overhead for both environments, making it significantly larger and more complex than either of the separate images. The advanced security posture of RHEL 10 could not be reliably enabled or leveraged.High Risk of Runtime Failure: The most significant danger of this approach is the risk of subtle, environment-specific failures. An image might build successfully in a CI environment but fail at runtime in a customer's production environment due to a mismatch between a library in the container and the host's kernel or system services. This violates the fundamental "build once, run anywhere" promise of containers 26 and creates a support nightmare that is difficult and costly to diagnose and resolve.Option B: The Separate Image Approach (Recommended)The recommended strategy is to maintain two distinct, purpose-built container images, managed through separate build pipelines and identified with clear, explicit tags.Example Tagging Scheme:our-registry/ansible-lint:rhel9 (Built on UBI 9, installing ansible-core 2.14)our-registry/ansible-lint:rhel10 (Built on UBI 10, installing ansible-core 2.16)Primary Benefits:Reliability and Stability: Each image is built and tested for a single, well-defined target platform. This eliminates all guesswork and environmental detection logic. The resulting artifacts are highly stable and predictable, as the environment they are tested in is identical to the one they will run in.Simplicity and Maintainability: The build process for each image is simple and linear. The Dockerfiles are clean and easy to understand. While there are two build pipelines to maintain, their simplicity makes them far less costly to manage than a single, highly complex one. The perceived "maintenance overhead" of two simple pipelines is a fallacy when compared to the total cost of ownership of a single, brittle, and complex artifact. The high development, testing, and long-term support costs of a unified image would far exceed the predictable and automatable cost of maintaining two separate images.Optimized Performance and Security: The RHEL 10 image can be built on a UBI 10 base without compromise, fully leveraging its smaller size, the performance benefits of the modern kernel and toolchain, and its advanced security features like PQC and enhanced SELinux.Clarity and User Experience: This approach is transparent and intuitive for users. They can explicitly select the image that matches their environment, removing ambiguity and reducing the likelihood of user error.Future-Proof Architecture: This model is inherently scalable. When RHEL 11 is released, a new ansible-lint:rhel11 image and build pipeline can be added without impacting the existing, stable images for RHEL 9 and RHEL 10.The following decision matrix provides a clear, comparative evaluation of the two strategies against key business and technical criteria.CriterionUnified Image ApproachSeparate Image ApproachReliabilityPoor. High risk of runtime failures due to dependency conflicts.Excellent. Each image is native to its target OS, ensuring stability.MaintainabilityPoor. Extremely complex build logic. High cost to debug and update.Good. Simple, duplicated build pipelines are easy to manage and automate.PerformanceFair. Forced to use lowest common denominator, negating RHEL 10 benefits.Excellent. Each image is optimized for its base OS, maximizing performance.SecurityFair. Cannot fully leverage RHEL 10's advanced security posture.Excellent. The RHEL 10 image can be built with all native security enhancements.User ExperiencePoor. "Magic" behavior is confusing. Failures are hard to diagnose.Excellent. Clear, explicit, and predictable for users.Future-ProofingPoor. Brittle design that is hard to extend to RHEL 11.Excellent. The model is easily extensible to future OS versions.OVERALL SCORE2.0 / 5.0 (Not Viable)4.8 / 5.0 (Recommended)Enterprise Testing and Deployment WorkflowsAdopting the recommended separate-image strategy requires a well-structured testing and deployment workflow that ensures the quality and reliability of both images, particularly within the mixed-version environments common to enterprise customers. The testing strategy must validate not only that each image works on its native platform but also that they are compatible with the transitional states customers will experience.Structuring a Multi-Version CI/CD PipelineA robust CI/CD pipeline is essential for automating the build, test, and release process for the two separate images. This pipeline should be designed to handle the parallel workflows efficiently.Source Control Strategy: The core Ansible content (playbooks, roles) that is being linted should remain in a single codebase. To manage the container builds, two distinct Dockerfiles should be maintained within the repository: Dockerfile.rhel9 and Dockerfile.rhel10. This keeps the build definitions separate and explicit.Parallel Pipeline Stages: The CI/CD pipeline, whether implemented in GitHub Actions, GitLab CI, or another tool, should be structured with parallel jobs to maximize efficiency.8Build Stage: Two parallel jobs are triggered on each commit. One job builds the ansible-lint:rhel9 image using Dockerfile.rhel9, and the other builds the ansible-lint:rhel10 image using Dockerfile.rhel10.Linting Stage: After the build stage, a set of jobs uses the newly created images to lint the target Ansible codebase. This serves as a basic sanity check, confirming that the linters themselves are functional and correctly configured.Integration Test Stage: This is the most critical validation step. Using a framework like Molecule, which is designed for testing Ansible roles, automated tests should be executed.28 These tests should not just run the linter but also execute simple playbooks inside actual RHEL 9 and RHEL 10 container environments. This validates that the entire toolchain, from the base image to ansible-core to ansible-lint, is functioning correctly.Publish Stage: Upon the successful completion of all prior stages, the versioned and tagged images (:rhel9 and :rhel10) are pushed to the designated container registry.Manual Testing and UAT for Mixed EnvironmentsWhile automation is key, manual and User Acceptance Testing (UAT) remain crucial for validating scenarios that are difficult or costly to automate. The focus should be on real-world customer configurations and, most importantly, the interoperability between RHEL versions.Enterprise customers will not perform a "big bang" upgrade from RHEL 9 to RHEL 10. They will operate in a mixed state for months or even years. Red Hat explicitly engineers its Universal Base Images for cross-version compatibility, meaning a UBI 9 container is supported on a RHEL 10 host, and vice versa.23 While the base OS layer is supported, the application layer—our ansible-lint tool and its dependencies—must also be validated in these mixed scenarios. A failure of our application in a supported configuration is still a failure of our product.Therefore, the testing strategy must validate the full compatibility matrix, not just the native endpoints. The manual testing workflow must include:Scenario 1: Running the ansible-lint:rhel9 container on a RHEL 9 host (Native).Scenario 2: Running the ansible-lint:rhel10 container on a RHEL 10 host (Native).Scenario 3: Running the ansible-lint:rhel9 container on a RHEL 10 host (Cross-Version).Scenario 4: Running the ansible-lint:rhel10 container on a RHEL 9 host (Cross-Version).Successfully passing these tests provides high confidence that the images will function reliably for customers throughout their transition period from RHEL 9 to RHEL 10.Impact on Enterprise CustomersThe separate image strategy, when paired with clear communication, has a net positive impact on enterprise customers operating in complex, heterogeneous environments.30Clarity and Predictability: This approach eliminates the ambiguity of a "magic" unified image. Customers know exactly which image to use for their specific environment. A team standardizing on RHEL 9 can use the :rhel9 tag with confidence in its stability and compatibility. A team migrating to RHEL 10 can immediately adopt the :rhel10 tag to gain access to the latest features and performance improvements. This clarity prevents support incidents caused by unexpected behavior.Managing Toolchain Integration: Customers will need to be made aware of the two distinct image tags. This requires clear documentation so they can update their internal tooling, such as CI/CD pipelines, security scanning policies, and deployment manifests. While this represents a minor initial effort for the customer, it is preferable to the unpredictable failures of a unified image.Empowering Customer Choice and Strategy: By providing two optimized images, this strategy empowers customers. It allows them to align their automation tooling with their own infrastructure roadmap. They are not forced to use a lowest-common-denominator tool but can instead choose the version that best fits their current and future needs. This flexibility is a key value proposition for enterprise clients.Customer Migration and Transition PathImplementing the recommended dual-image strategy requires a clear and well-communicated migration plan for existing users. The goal is to guide users to the new, explicitly tagged images smoothly, minimize disruption to their workflows, and use the transition as an opportunity to highlight the benefits of the new RHEL 10-based offering. A phased approach is recommended to ensure a successful rollout.Phased Rollout StrategyA multi-phase plan allows for a gradual transition, providing users with ample time to adapt while establishing the RHEL 10 image as the new standard.Phase 1: Announcement and Initial Release (Weeks 0-4)Communication: Publish comprehensive documentation detailing the new dual-image strategy. This documentation must clearly explain the rationale behind the decision, emphasizing the benefits of improved stability, performance, and security.Release: Release both the our-registry/ansible-lint:rhel9 and our-registry/ansible-lint:rhel10 images simultaneously.Backward Compatibility: To prevent breaking existing user pipelines, the generic :latest tag must initially be updated to point to the :rhel9 image. This ensures that users who have not yet updated their configurations will continue to receive a compatible image.Phase 2: Transition and Promotion (Weeks 4-12)Active Promotion: Begin a communication campaign to actively promote the benefits of the new :rhel10 image. This should highlight the performance gains, smaller image size, and advanced security features detailed in Section 3 of this report.Documentation Updates: All official documentation, README files, tutorials, and example code must be updated to use the new, explicit tags (:rhel9 and :rhel10) instead of :latest.In-Tool Notification: A warning message should be added to the startup log of the :rhel9 image. This message should inform users about the availability of the new :rhel10 image and announce the upcoming date when the :latest tag will be redirected.Phase 3: :latest Tag Redirection (Week 12)After a three-month grace period, the :latest tag should be officially retagged to point to the :rhel10 image. This action formally establishes the RHEL 10 version as the new default and recommended standard for new projects.This change must be communicated clearly and widely across all channels (e.g., release notes, blog posts, community forums) at least two weeks prior to the change and again on the day of the change.Phase 4: Deprecation of Old Images (Months 6-12)After six months, announce a formal deprecation timeline for any legacy images that do not follow the new tagging convention. This provides a clear end-of-life for older artifacts and encourages all users to migrate to the fully supported, explicitly tagged images.Documentation and Communication PlanClear, proactive communication is the cornerstone of a successful migration. The documentation should not only state what is changing but, more importantly, why it is changing.Dedicated Migration Guide: A new documentation page titled "Migrating to the New RHEL-Based ansible-lint Images" should be created. This guide will serve as the central source of truth for the transition. It should include:A summary of the rationale (aligning with RHEL ansible-core versions).Copy-and-paste examples for updating Dockerfiles, docker-compose.yml files, CI/CD scripts (like .gitlab-ci.yml or GitHub Actions workflows), and Kubernetes deployment manifests.Clear Tagging Policy: The documentation must explicitly define the new image tagging policy. For example:ansible-lint:rhel9: A floating tag that always points to the latest stable release for the RHEL 9 series.ansible-lint:rhel9-v1.2.3: An immutable tag for a specific version.ansible-lint:rhel10: A floating tag for the RHEL 10 series.ansible-lint:rhel10-v1.2.3: An immutable tag for a specific RHEL 10 version.Use-Case Guidance: The migration itself is an opportunity to educate users and promote the value of the new platform. The documentation should provide clear guidance on which image to choose, framing it not as a chore but as a strategic choice. For example:"For maximum compatibility with automation targeting or running on RHEL 9 hosts, use the :rhel9 tag. This ensures your linting environment perfectly matches the long-term supported ansible-core 2.14.""For the best performance, smallest image size, and most advanced security features, including Post-Quantum Cryptography, use the :rhel10 tag. This is the recommended choice for all new projects and for environments migrating to RHEL 10."By framing the migration in this way, the required action of changing an image tag becomes a moment for the user to make a value-driven decision. It encourages them to adopt the superior RHEL 10-based offering and helps them build the business case for their own organization's migration to the next generation of Red Hat Enterprise Linux.